
* Soroban

try to implement a infinity Soroban Board and simulator / Assistent

** Idea

use i64 as a board representation, since boards are associatives (this idea/information has not come to my mind before, this is way the main idea take so long) and values can been easily multiply by the new number/scale of necessary boards add, thereis a ways and sheap way of implement this with dynamic arrays using Odin buildin dynamic array and the i64

the i64 or int64_t on C, are a great way to have a board representation, because is a conveninent number, that can been expoerted/dumped and used on another language without so much conversion

the calculations show that it can perform a 12 roads board of Soroban with can proficiently handle a 1 trilion digit board support on the 1.8E19 combinations of the i64 (2^64), with this, a association of boards can been perform

the main idea is that the board is on a configuration on with the numbers are on a sequence on the binary representation of the number, using each bit to represent a uppper bead (with can bee associated on the lower beads to bee positive upper beads too (or down beads on the 5 bead value on the top of the soroban)).

bellow a board representation illustration (with the 12 roads)

#+begin_src text
-----------------------------------------------
<|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|>
 |   |   |   |   |   |   |   |   |   |   |   |
-----------------------------------------------
 |   |   |   |   |   |   |   |   |   |   |   |
<|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|>
<|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|>
<|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|>
<|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|> <|>
-----------------------------------------------
#+end_src

for this board, we only need to represent the beads, if they are upper or down, and with this configurations, using a assuptions of a array of bits / booleans

#+begin_src lua
[ 0  0  0  0  0  0  0  0  0  0  0  0 ]
[ 0  0  0  0  0  0  0  0  0  0  0  0 ]
[ 0  0  0  0  0  0  0  0  0  0  0  0 ]
[ 0  0  0  0  0  0  0  0  0  0  0  0 ]
[ 0  0  0  0  0  0  0  0  0  0  0  0 ]
#+end_src

with this binary representation, we can serialize this on a binary number, on the 64 bits of a i64

bellow the 64 bits of a i64

#+begin_src lua
[ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]
#+end_src

on with we take 5 bits each to represent a road ( with have 5 beads total )

#+begin_src lua
[ 0 0 0 0 0 0 0 0 0 0 0 0   --- top 1, value 5 beads on
  0 0 0 0 0 0 0 0 0 0 0 0   --- bead value 1
  0 0 0 0 0 0 0 0 0 0 0 0   --- bead value 2
  0 0 0 0 0 0 0 0 0 0 0 0   --- bead value 3
  0 0 0 0 0 0 0 0 0 0 0 0   --- bead value 4
  | 0 0 0 ] --- three last bits that can bee used of represent boards states, if necessary
#+end_src

there is 12 roads on with the top and botton, if one road is active on a bit, of one colum, they will active value of the road of this road, this is exception of the road of the top, with active, value +5 on the road on question.

with this approuch, xor | bitwish operations will been more performantic and more eficient for more disclosure and even multiplications for zeration of ceart parts of the board. of instance, enable 4 on botton will make any road on the botton, to been zero. for instance, we can create with bitwish operations MACRO numbers to represent board default states, and check for places where there is values, more eficiently as well as setting new state of the board more rapidly

*** Simulator / Interpreter

The board will use a little instruction/Enum interpreter on with they are a array of tuple of road number* and instruction on with

bellown a pseudo-code / haskell-like

#+begin_src odin
dynamic [(possition : i64, asm_ins : Soroban_Instruction )]
#+end_src

perform operation on the abacus for doing the calculations and work as a interface for the infinity* soroban simulation .

the simulation, will receive a board ( a actualy number of i64 type ) that then, will perform operation acordly with MACRO numbers and the instructions, the idea is that can been performatic and easy to check.

The Instructions and ADT

#+begin_src odin

MAX_ROAD_PER_SOROBAN_BOARD :: 12
MAX_SOROBAN_INSTRUCTIONS_PER_BOARD :: 8192 // 2^13
MAX_SOROBAN_OPERATIONS_PER_BOARD :: 64

SB_Addition :: struct {
	first_value : i64,
	second_value : i64,
	SB_Instructions : [MAX_INSTRUCTIONS_PER_BOARD]Soroban_Instructions
}
SB_Multiplication :: struct {
	first_value : i64,
	second_value : i64,
	SB_Instructions : [MAX_INSTRUCTIONS_PER_BOARD]Soroban_Instructions
}
SB_Subtration :: struct {
	first_value : i64,
	second_value : i64,
	SB_Instructions : [MAX_INSTRUCTIONS_PER_BOARD]Soroban_Instructions
}
SB_Division :: struct {
	first_value : i64,
	second_value : i64,
	SB_Instructions : [MAX_INSTRUCTIONS_PER_BOARD]Soroban_Instructions
}
SB_Square_Root :: struct {
	first_value : i64,
	second_value : i64,
	SB_Instructions : [MAX_INSTRUCTIONS_PER_BOARD]Soroban_Instructions
}
SB_Cubic_Square :: struct {
	first_value : i64,
	second_value : i64,
	SB_Instructions : [MAX_INSTRUCTIONS_PER_BOARD]Soroban_Instructions
}

Operation_Soroban_Type :: enum {
	SB_Addition,
	SB_Multiplication,
	SB_Subtration,
	SB_Division,
	SB_Square_Root,
	SB_Cubic_Square,
};

Soroban_Board :: struct {
	board : i64,
	current_state_board_eval : i64,
	current_instruction : Soroban_Instructions,
	MAX_ROADS : i64 = MAX_ROAD_PER_SOROBAN_BOARD,
	scale_board : i64 = 1, // value to consider for scaling state eval
	idx_road : i64,
	idx_board : i64,
};

Soroban_Operations :: struct {
	current_instruction_idx : i64,
	index_operation : i64,
	index_number_operated_for : i64,
	Operations : [MAX_SOROBAN_OPERATIONS_PER_BOARD]Operation_Soroban_Type,
	Numbers_in_operation_by_operations : [MAX_SOROBAN_OPERATIONS_PER_BOARD]f64,
}

Infini_Soroban :: struct {
	[dynamic]Soroban_Board,
	total_state_of_boards : i64,
	idx_current_board : i64,
	idx_globa_current_road : i64,
	number_of_boards : i64,
	MAX_BOARDS : i64,
	operations : Soroban_Operations,
}

Soroban_Instructions :: enum {
INS_SB_ADD_1,
INS_SB_ADD_2,
INS_SB_ADD_3,
INS_SB_ADD_4,
INS_SB_ADD_5,
INS_SB_SUB_1,
INS_SB_SUB_2,
INS_SB_SUB_3,
INS_SB_SUB_4,
INS_SB_SUB_5,

// this instructions do not make sense on the board, since they are instructions that take place on the board abstract idea.
// INS_SB_COMPL_5,
// INS_SB_COMPL_10,
// INS_SB_RELATIVE_ADD,
// INS_SB_RELATIVE_SUB,

};

INS_SB_ADD_1 :: struct {
	MACRO_NUMBER_INS_SB_ADD_1 : i64,
}
INS_SB_ADD_2 :: struct {
	MACRO_NUMBER_INS_SB_ADD_2 : i64,
}
INS_SB_ADD_3 :: struct {
	MACRO_NUMBER_INS_SB_ADD_3 : i64,
}
INS_SB_ADD_4 :: struct {
	MACRO_NUMBER_INS_SB_ADD_4 : i64,
}
INS_SB_ADD_5 :: struct {
	MACRO_NUMBER_INS_SB_ADD_5 : i64,
}
INS_SB_SUB_1 :: struct {
	MACRO_NUMBER_INS_SB_SUB_1 : i64,
}
INS_SB_SUB_2 :: struct {
	MACRO_NUMBER_INS_SB_SUB_2 : i64,
}
INS_SB_SUB_3 :: struct {
	MACRO_NUMBER_INS_SB_SUB_3 : i64,
}
INS_SB_SUB_4 :: struct {
	MACRO_NUMBER_INS_SB_SUB_4 : i64,
}
INS_SB_SUB_5 :: struct {
	MACRO_NUMBER_INS_SB_SUB_5 : i64,
}

#+end_src

DISCLAIMER .: pay attention that this code can been out of date with the actual code on the source, also, that this is not intent to been working code, but a touth exercise on who to model the Data Structure to represent the code. and this example code, need to been fuder analise for better design also, operations and instructions (bytecode asm) needs to been distinct on the actual code and simulation part.

** TODO

now we need to implement a framework/library to deal with this idea of board configuration and exceptions*, including f*cking NaN of the [[https://en.wikipedia.org/wiki/IEEE_754][IEEE_754]]

with this memory leout, we can deal easily with infinity* soroban boards, with pretty much no cost at all on memory... (hopefully)

** research

there is also a possible and easy to use conversion using Gray Code for dealing with the amount of bitwish operations, but we can work arround that using matrix* bitwish operations directly on the i64.

** demos



** motivation

try to implement a infinity Soroban Board. ( also a assistend for self learn and testing with statistics and measurements )

the magic of the abacus make me think if there is any way to perform more eficient operation on the board (and test,mesure this), and always think on how this can been perform (on a Rubik's Cube twoo)

the ultimante goal of this project is perform a generic algoritm with markov chains to generate random moviments on with they are selected on a Monte Carlo Simulation, to perform operations that are closer to the actual or even correct response ( and isolete then with statistics, exporting data for fother examination ) for operations with the determined number and operation on the soroban.

the main idead is also, to perform a nealy infinity Soroban on with they can perform infinity* calculations, as simulations .


* version of [[https://github.com/odin-lang/odin][Odin]]

dev-2023-11:ef5eb4b6
